function Zsh::init {
	# Path to your oh-my-zsh configuration.
	ZSH=~/.oh-my-zsh

	# Set name of the theme to load.
	# Look in ~/.oh-my-zsh/themes/
	# Optionally, if you set this to "random", it'll load a random theme each
	# time that oh-my-zsh is loaded.
	#ZSH_THEME="gianu"
	#ZSH_THEME="cypher"
	#ZSH_THEME="rkj"
	ZSH_THEME="candy"

	# Set this to use case-sensitive completion
	# CASE_SENSITIVE="true"

	# Uncomment this to disable bi-weekly auto-update checks
	# DISABLE_AUTO_UPDATE="true"

	# Uncomment to change how often to auto-update? (in days)
	export UPDATE_ZSH_DAYS=13

	# Uncomment following line if you want to disable colors in ls
	# DISABLE_LS_COLORS="true"

	# Uncomment following line if you want to disable autosetting terminal title.
	# DISABLE_AUTO_TITLE="true"

	# Uncomment following line if you want to disable command autocorrection
	# DISABLE_CORRECTION="true"

	# Uncomment following line if you want red dots to be displayed while waiting for completion
	# COMPLETION_WAITING_DOTS="true"

	# Uncomment following line if you want to disable marking untracked files under
	# VCS as dirty. This makes repository status check for large repositories much,
	# much faster.
	# DISABLE_UNTRACKED_FILES_DIRTY="true"

	# Uncomment following line if you want to the command execution time stamp shown
	# in the history command output.
	# The optional three formats: "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"
	HIST_STAMPS="yyyy/mm/dd"

	# Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)
	# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/
	# Example format: plugins=(rails git textmate ruby lighthouse)
	plugins=(
		tmux
		git github git-flow
		node npm grunt coffee
		pip python fabric
		ruby rails
		#thefuck
	)

	source $ZSH/oh-my-zsh.sh
}


function System::release_name {
	DEBIAN_RELEASE_FILE="/etc/lsb-release"
	REDHAT_RELEASE_FILE="/etc/redhat-release"

	# OS_TYPE : linux / osx / unknown ...
	# 맥의 경우는 환경설정이 달라질때가 많다.
	# 매번 확인하기 귀찮아서 환경변수로 설정

	if [ -f $DEBIAN_RELEASE_FILE ]; then
		# ubuntu, debian, etc
		local DIST_NAME=`sed -n 's/^DISTRIB_ID=//p' $DEBIAN_RELEASE_FILE`
		local DIST_VERSION=`sed -n 's/^DISTRIB_RELEASE=//p' $DEBIAN_RELEASE_FILE`
		DIST_FULLNAME="$DIST_NAME $DIST_VERSION"
		export OS_TYPE="linux"
	elif [ -f $REDHAT_RELEASE_FILE ]; then
		# centos
		DIST_FULLNAME=`cat $REDHAT_RELEASE_FILE`
		export OS_TYPE="linux"
	elif [ -d "/Applications" ]; then
		# 맥인지 확인하는 무식한 방법
		# 설마 리눅스에서 /Applications 디렉토리를 만들겠어?
		local DIST_NAME=$(sw_vers -productName)
		local DIST_VERSION=$(sw_vers -productVersion)
		local DIST_BUILD=$(sw_vers -buildVersion)
		DIST_FULLNAME="$DIST_NAME $DIST_VERSION $DIST_BUILD"
		export OS_TYPE="osx"
	else
		DIST_FULLNAME="Unknown Distribution"
		export OS_TYPE="unknown"
	fi
}

function System::environment {
	if [[ $USER == "haruna" ]]; then
		ENV_NAME="Work"
	elif [[ $USER == "amane" ]]; then
		ENV_NAME="Work"
	elif [[ $USER == "pi" ]]; then
		ENV_NAME="Raspberry Pi"
	else
		ENV_NAME="Home"
	fi
}

function System::env_hook_rpi {
	alias ssh-pi="ssh pi@192.168.0.16"
}

function System::init {
	System::release_name
	System::environment

	if [[ $ENV_NAME == "pi" ]]; then
		System_env_hook_rpi
	fi
}

function System::display {
	echo ""
	echo "## Environment"
	echo "OS Type\t\t: ${OS_TYPE}"
	echo "User\t\t: ${USER}"
	echo "Computer\t: ${DIST_FULLNAME}"
	echo "Environment\t: ${ENV_NAME}"
	echo ""
}

function Shell::init {
	# User configuration
	export PATH="/usr/lib/lightdm/lightdm:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games"
	export MANPATH="/usr/local/man:$MANPATH"
	export PATH="$HOME/bin:$PATH"

	# # Preferred editor for local and remote sessions
	if [[ -n $SSH_CONNECTION ]]; then
		export EDITOR='vim'
	else
		export EDITOR='vim'
	fi
	export VISUAL=$EDITOR

	# Compilation flags
	export ARCHFLAGS="-arch x86_64"

	# python encoding
	export PYTHONIOENCODING="utf-8"

	# ssh
	export SSH_KEY_PATH="~/.ssh/id_rsa"

	export LC_ALL=ko_KR.UTF-8
	export LANG=ko_KR.UTF-8

	if [ -f "~/.autoenv/" ]; then
	    source ~/.autoenv/activate.sh
	fi

	# the fuck
	# https://github.com/nvbn/thefuck
	# eval "$(thefuck --alias)"

	# less + syntax highlight
	# http://superuser.com/questions/117841/get-colors-in-less-command
	export LESS='-R'
	export LESSOPEN='|~/.lessfilter %s'

	Shell::alias
}

function Shell::alias {
	alias cd...='cd ../..'
	alias cd....='cd ../../..'
	alias cd.....='cd ../../../..'
	alias cd......='cd ../../../../..'

	# cls is dos command. but it is short than clear.
	alias cls='clear'

	alias emasc='emacs'
	alias e='emacs'

	# use color
	alias less='less -R'

	# apt-get install ack-grep
	# linux : ack-grep
	# osx : ack
	unalias ack 2> /dev/null
	ack_exist=$(which ack > /dev/null 2> /dev/null; echo $?)
	ack_grep_exist=$(which ack-grep > /dev/null 2> /dev/null; echo $?)
	if [[ $ack_grep_exist == "0" ]] && [[ $ack_exist != "0" ]]; then
		echo "[Shell]\t ack-grep found, ack not found => enable ack alias"
		alias ack='ack-grep'
	fi

	alias ipconfig='ifconfig'

	# mcs/gmcs 둘다 돌아가도록
	mcs_exist=$(which mcs > /dev/null 2> /dev/null; echo $?)
	gmcs_exist=$(which gmcs > /dev/null 2> /dev/null; echo $?)
	if [[ $mcs_exist == "0" ]] && [[ $gmcs_exist != "0" ]]; then
		alias gmcs="mcs"
	fi
	if [[ $gmcs_exist == "0" ]] && [[ $mcs_exist != "0" ]]; then
		alias mcs="gmcs"
	fi

	# not recommend. python embedded web server is slow
	# user npm install -g http-server
	alias serve='python -m SimpleHTTPServer'

	alias py2='python2'
	alias py3='python3'
}

ANDROID_ROOT_DIR_LIST=(
	~/android
	/opt
	/opt/android
	/usr/local/opt
)

function Android::init {
	Android::sdk_init
	Android::ndk_init
	Android::ccache
}

function Android::sdk_init {
	Android::set_sdk_dir ""
	ANDROID_SDK_NAME_LIST=(
		"android-sdk"
		# for linux
		"android-sdk-linux"
		# for osx
		"android-sdk-macosx"
		"adt-bundle-mac-x86_64"
	)

	# find android sdk
	for ANDROID_ROOT_DIR in ${ANDROID_ROOT_DIR_LIST[@]}; do
		for android_sdk_name in ${ANDROID_SDK_NAME_LIST[@]}; do
			local TARGET_DIR=${ANDROID_ROOT_DIR}/${android_sdk_name}
			if [ -d $TARGET_DIR ]; then
				Android::set_sdk_dir $TARGET_DIR
				return
			fi
		done
	done
}

function Android::ndk_init {
	Android::set_ndk_dir ""

	# find android ndk
	for ANDROID_ROOT_DIR in ${ANDROID_ROOT_DIR_LIST[@]}; do
		if [ ! -d $ANDROID_ROOT_DIR ]; then
			continue;
		fi

		for f in $(ls $ANDROID_ROOT_DIR | sort -r); do
			local TARGET=${ANDROID_ROOT_DIR}/$f
			if [ -f $TARGET ]; then
				continue
			fi
			if [[ $f == *"ndk"* ]]; then
				Android::set_ndk_dir $TARGET
			fi
		done
	done
}

function Android::set_sdk_dir {
	if [[ "$1" == "" ]]; then
		unset ANDROID_SDK_ROOT
		unset ANDROID_HOME
	else
		export PATH=$1/platform-tools:$PATH
		export PATH=$1/tools:$PATH
		export ANDROID_SDK_ROOT=$1
		export ANDROID_HOME=$1
	fi
}

function Android::set_ndk_dir {
	if [[ "$1" == "" ]]; then
		unset ANDROID_NDK_VERSION
		unset ANDROID_NDK_ROOT
		unset NDK_ROOT
	else
		# example : android-ndk-r8e
		export ANDROID_NDK_VERSION=`expr "$1" : '.*ndk-\(r[0-9]*[a-z]\)'`
		export ANDROID_NDK_ROOT=$1
		export NDK_ROOT=$1
		export PATH=${ANDROID_NDK_ROOT}:$PATH
	fi
}

function Android::display {
	echo "## Android"

	if [[ $ANDROID_SDK_ROOT == "" ]]; then
		echo "Android SDK is not exist"
	else
		echo "Android SDK\t: ${ANDROID_SDK_ROOT}"
	fi

	if [[ $ANDROID_NDK_ROOT == "" ]]; then
		echo "NDK is not exist"
	else
		echo "NDK(${ANDROID_NDK_VERSION})\t: ${ANDROID_NDK_ROOT}"
	fi

	if [[ $NDK_CCACHE == "" ]]; then
		echo "ccache is not exist"
	else
		echo "ccache\t\t: Enabled"
	fi
	echo ""
}

function Android::ccache {
	export NDK_CCACHE=`which ccache`
	if [[ $NDK_CCACHE == "ccache not found" ]]; then
		NDK_CCACHE=""
	fi
}


function Android::reset_adb {
	# http://stackoverflow.com/questions/9210152/set-up-device-for-development-no-permissions
	# Fix this problem
	# List of devices attached
	# ????????????    no permissions
	# Configure udev or use root permission
	# I use root permission becuase zshrc configuration file is used in many computer.
	sudo adb kill-server
	sudo adb start-server
	sudo adb devices
}

function Android::setup {
	#http://stackoverflow.com/questions/22701405/aapt-ioexception-error-2-no-such-file-or-directory-why-cant-i-build-my-grad
	# for x86_64 + android sdk
	sudo apt-get install lib32stdc++6 lib32z1
}

function Nodejs::init {
	if [[ -s $HOME/.nvm/nvm.sh ]]; then
		. ~/.nvm/nvm.sh

		nvm_version=$(nvm --version)
		echo "nvm version : $nvm_version"
	fi
}

function Go::init {
	# raspberry pi에서는 환경변수 추가세팅 안하면 문제 발생
	# 아키텍쳐에 의한 버그
	# https://www.raspberrypi.org/forums/viewtopic.php?f=34&t=10781
	# https://github.com/golang/go/wiki/GoArm
	case $(uname -m) in
		"armv5l")
			export GOARM="5"
			;;
		"armv6l")
			export GOARM="6"
			;;
		"armv7l")
			export GOARM="7"
			;;
		"armv8l")
			export GOARM="arm64"
			;;
	esac

	if [[ -s $HOME/.gvm/scripts/gvm ]]; then
		source $HOME/.gvm/scripts/gvm

		gvm_version=$(gvm version | sed 's/Go Version Manager //g')
		echo "gvm version : $gvm_version"
	fi
}

function Ruby::init {
	RBENV_ROOT=$HOME/.rbenv

	if [[ -s $RBENV_ROOT/bin/rbenv ]]; then
		export PATH=$RBENV_ROOT/bin:$PATH
		export PATH=$RBENV_ROOT/plugins/ruby-build/bin:$PATH

		eval "$(rbenv init -)"

		rbenv_version=$(rbenv 2>&1 > /dev/null | head -n 1 | sed 's/rbenv //g')
		echo "rbenv version : $rbenv_version"
	fi
}

function Python::init {
	PYENV_ROOT="$HOME/.pyenv"

	if [[ -s $PYENV_ROOT/bin/pyenv ]]; then
		export PATH="$PYENV_ROOT/bin:$PATH"

		eval "$(pyenv init -)" || 1
		eval "$(pyenv virtualenv-init - 2> /dev/null)" || 1

		pyenv_version=$(pyenv 2>&1 > /dev/null | head -n 1 | sed 's/pyenv //g')
		echo "pyenv version : $pyenv_version"
	fi
}

function Rust::init {
	if [[ -s $HOME/.cargo/env ]]; then
		source $HOME/.cargo/env

		cargo_version=$(cargo version 2>&1 > /dev/null | head -n 1 | sed 's/cargo //g')
		echo "cargo version : $cargo_version"
	fi
}

function Emacs::init {
	export PATH="$HOME/.cask/bin:$PATH"
}

function Cocos2dX::init {
	cocos_x_src_path=$HOME/devel/cocos2d-x-3.10
	cocos_x_root=$HOME/devel

	# Add environment variable COCOS_CONSOLE_ROOT for cocos2d-x
	export COCOS_CONSOLE_ROOT=$cocos_x_src_path/tools/cocos2d-console/bin
	export PATH=$COCOS_CONSOLE_ROOT:$PATH

	# Add environment variable COCOS_X_ROOT for cocos2d-x
	export COCOS_X_ROOT=$cocos_x_root
	export PATH=$COCOS_X_ROOT:$PATH

	# Add environment variable COCOS_TEMPLATES_ROOT for cocos2d-x
	export COCOS_TEMPLATES_ROOT=$cocos_x_src_path/templates
	export PATH=$COCOS_TEMPLATES_ROOT:$PATH
}

function Travis::init {
	[ -f $HOME/.travis/travis.sh ] && source $HOME/.travis/travis.sh
}

function MacOSX::init {
	if [[ $OS_TYPE != "osx" ]]; then
		return
	fi

	echo "## MacOSX "

	# mysql
	# http://stackoverflow.com/questions/10557507/rails-mysql-on-osx-library-not-loaded-libmysqlclient-18-dylib
	MYSQL=/usr/local/mysql/bin
	if [ -d $MYSQL ]; then
		echo "mysql detected"
		export PATH=$PATH:$MYSQL
		export DYLD_LIBRARY_PATH=/usr/local/mysql/lib:$DYLD_LIBRARY_PATH
	fi

	# emacs
	local emacs_path="/usr/local/opt/emacs/bin"
	if [ -d $emacs_path ]; then
		echo "emacs detected"
		export PATH=/usr/local/opt/emacs/bin:$PATH
	fi

	# hangul locale
	export LC_ALL="ko_KR.UTF-8"
	export LANG="ko_KR.UTF-8"

	echo ""
}

function Local::init {
	local zshrc_local="$HOME/.zshrc.local"
	if [ ! -f $zshrc_local ]; then
		return
	fi

	echo "## Local"
	echo "Include Local zshrc"
	source $zshrc_local
	echo ""
}

zmodload zsh/datetime

function Dotfiles::init {
	Dotfiles::update
}

function _current_epoch() {
	echo $(( $EPOCHSECONDS / 60 / 60 / 24 ))
}

function Dotfiles::update_repo {
	curr_path=$(pwd)
	cd ~/.dotfiles
	git pull origin master
	cd $curr_path

	Dotfiles::update_timestamp
}
function Dotfiles::update_timestamp {
	echo "LAST_EPOCH=$(_current_epoch)" >! ~/.dotfiles-update
}
function Dotfiles::update {
	# https://github.com/robbyrussell/oh-my-zsh/blob/master/tools/check_for_upgrade.sh

	if [ -f ~/.dotfiles-update ]; then
		. ~/.dotfiles-update

		epoch_target=1

		if [[ -z "$LAST_EPOCH" ]]; then
			Dotfiles::update_timestamp && return 0;
		fi

		epoch_diff=$(($(_current_epoch) - $LAST_EPOCH))
		if [ $epoch_diff -gt $epoch_target ]; then
			if [ "$DISABLE_UPDATE_PROMPT" = "true" ]; then
				_upgrade_zsh
			else
				echo "[Dotfiles] Would you like to check for updates? [Y/n]: \c"
				read line
				if [ "$line" = Y ] || [ "$line" = y ] || [ -z "$line" ]; then
					Dotfiles::update_repo
				else
					Dotfiles::update_timestamp
				fi
			fi
		fi
	else
		# create the timestamp file
		Dotfiles::update_timestamp
	fi
}

cd ~
Zsh::init
Dotfiles::init
Shell::init
System::init
System::display

# OSX 초기화를 먼저 하지 않으면 brew로 문제 생길 가능성이 있다
MacOSX::init

Emacs::init
Android::init
Android::display
Cocos2dX::init
Travis::init

# 언어 관련 설정은 나중
echo "## Language"
Ruby::init
Python::init
Nodejs::init
Go::init
Rust::init

Local::init

echo "Hello, $USER."

### Added by the Heroku Toolbelt
export PATH="/usr/local/heroku/bin:$PATH"

# Add GHC 7.10.2 to the PATH, via https://ghcformacosx.github.io/
export GHC_DOT_APP="/Applications/ghc-7.10.2.app"
if [ -d "$GHC_DOT_APP" ]; then
	export PATH="${HOME}/.local/bin:${HOME}/.cabal/bin:${GHC_DOT_APP}/Contents/bin:${PATH}"
fi
