function Zsh::init {
	# Path to your oh-my-zsh configuration.
	ZSH=~/.oh-my-zsh

	# Set name of the theme to load.
	# Look in ~/.oh-my-zsh/themes/
	# Optionally, if you set this to "random", it'll load a random theme each
	# time that oh-my-zsh is loaded.
	ZSH_THEME="gianu"

	# Set this to use case-sensitive completion
	# CASE_SENSITIVE="true"

	# Uncomment this to disable bi-weekly auto-update checks
	# DISABLE_AUTO_UPDATE="true"

	# Uncomment to change how often to auto-update? (in days)
	export UPDATE_ZSH_DAYS=13

	# Uncomment following line if you want to disable colors in ls
	# DISABLE_LS_COLORS="true"

	# Uncomment following line if you want to disable autosetting terminal title.
	# DISABLE_AUTO_TITLE="true"

	# Uncomment following line if you want to disable command autocorrection
	# DISABLE_CORRECTION="true"

	# Uncomment following line if you want red dots to be displayed while waiting for completion
	# COMPLETION_WAITING_DOTS="true"

	# Uncomment following line if you want to disable marking untracked files under
	# VCS as dirty. This makes repository status check for large repositories much,
	# much faster.
	# DISABLE_UNTRACKED_FILES_DIRTY="true"

	# Uncomment following line if you want to the command execution time stamp shown
	# in the history command output.
	# The optional three formats: "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"
	HIST_STAMPS="yyyy/mm/dd"

	# Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)
	# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/
	# Example format: plugins=(rails git textmate ruby lighthouse)
	plugins=(
		tmux
		git github git-flow
		node npm grunt coffee
		pip python fabric
		ruby rails
		thefuck
	)

	source $ZSH/oh-my-zsh.sh
}


function System::release_name {
	DEBIAN_RELEASE_FILE="/etc/lsb-release"
	REDHAT_RELEASE_FILE="/etc/redhat-release"

	# OS_TYPE : linux / osx / unknown ...
	# 맥의 경우는 환경설정이 달라질때가 많다.
	# 매번 확인하기 귀찮아서 환경변수로 설정

	if [ -f $DEBIAN_RELEASE_FILE ]; then
		# ubuntu, debian, etc
		local DIST_NAME=`sed -n 's/^DISTRIB_ID=//p' $DEBIAN_RELEASE_FILE`
		local DIST_VERSION=`sed -n 's/^DISTRIB_RELEASE=//p' $DEBIAN_RELEASE_FILE`
		DIST_FULLNAME="$DIST_NAME $DIST_VERSION"
		export OS_TYPE="linux"
	elif [ -f $REDHAT_RELEASE_FILE ]; then
		# centos
		DIST_FULLNAME=`cat $REDHAT_RELEASE_FILE`
		export OS_TYPE="linux"
	elif [ -d "/Applications" ]; then
		# 맥인지 확인하는 무식한 방법
		# 설마 리눅스에서 /Applications 디렉토리를 만들겠어?
		local DIST_NAME=$(sw_vers -productName)
		local DIST_VERSION=$(sw_vers -productVersion)
		local DIST_BUILD=$(sw_vers -buildVersion)
		DIST_FULLNAME="$DIST_NAME $DIST_VERSION $DIST_BUILD"
		export OS_TYPE="osx"
	else
		DIST_FULLNAME="Unknown Distribution"
		export OS_TYPE="unknown"
	fi
}

function System::environment {
	if [[ $USER == "haruna" ]]; then
		ENV_NAME="Work"
	elif [[ $USER == "amane" ]]; then
		ENV_NAME="Work"
	elif [[ $USER == "pi" ]]; then
		ENV_NAME="Raspberry Pi"
	else
		ENV_NAME="Home"
	fi
}

function System::env_hook_rpi {
	alias ssh-pi="ssh pi@192.168.0.16"
}

function System::init {
	System::release_name
	System::environment

	if [[ $ENV_NAME == "pi" ]]; then
		System_env_hook_rpi
	fi
}

function System::display {
	echo ""
	echo "## Environment"
	echo "OS Type\t\t: ${OS_TYPE}"
	echo "User\t\t: ${USER}"
	echo "Computer\t: ${DIST_FULLNAME}"
	echo "Environment\t: ${ENV_NAME}"
	echo ""
}

function Shell::init {
	# User configuration
	export PATH="/usr/lib/lightdm/lightdm:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games"
	export MANPATH="/usr/local/man:$MANPATH"
	export PATH="/home/${USER}/bin:$PATH"

	# # Preferred editor for local and remote sessions
	if [[ -n $SSH_CONNECTION ]]; then
		export EDITOR='vim'
	else
		export EDITOR='vim'
	fi
	export VISUAL=$EDITOR

	# Compilation flags
	export ARCHFLAGS="-arch x86_64"

	# python encoding
	export PYTHONIOENCODING="utf-8"

	# ssh
	export SSH_KEY_PATH="~/.ssh/id_rsa"

	source ~/.autoenv/activate.sh

	# the fuck
	# https://github.com/nvbn/thefuck
	eval "$(thefuck --alias)"

	Shell::alias
}

function Shell::alias {
	alias cd...='cd ../..'
	alias cd....='cd ../../..'
	alias cd.....='cd ../../../..'
	alias cd......='cd ../../../../..'

	# cls is dos command. but it is short than clear.
	alias cls='clear'

	alias emasc='emacs'
	alias e='emacs'

	# use color
	alias less='less -R'

	# apt-get install ack-grep
	# linux : ack-grep
	# osx : ack
	unalias ack 2> /dev/null
	ack_exist=$(which ack > /dev/null 2> /dev/null; echo $?)
	ack_grep_exist=$(which ack-grep > /dev/null 2> /dev/null; echo $?)
	if [[ $ack_grep_exist == "0" ]] && [[ $ack_exist != "0" ]]; then
		echo "[Shell]\t ack-grep found, ack not found => enable ack alias"
		alias ack='ack-grep'
	fi

	alias ipconfig='ifconfig'

	# not recommend. python embedded web server is slow
	# user npm install -g http-server
	alias serve='python -m SimpleHTTPServer'

	alias py2='python2'
	alias py3='python3'
}

ANDROID_ROOT_DIR_LIST=(
	~/android
	/opt
	/opt/android
)

function Android::init {
	Android::sdk_init
	Android::ndk_init
	Android::ccache
}

function Android::sdk_init {
	Android::set_sdk_dir ""
	ANDROID_SDK_NAME_LIST=(
		# for linux
		"android-sdk-linux"
		# for osx
		"android-sdk-macosx"
		"adt-bundle-mac-x86_64"
	)

	# find android sdk
	for ANDROID_ROOT_DIR in ${ANDROID_ROOT_DIR_LIST[@]}; do
		for android_sdk_name in ${ANDROID_SDK_NAME_LIST[@]}; do
			local TARGET_DIR=${ANDROID_ROOT_DIR}/${android_sdk_name}
			if [ -d $TARGET_DIR ]; then
				Android::set_sdk_dir $TARGET_DIR
				return
			fi
		done
	done
}

function Android::ndk_init {
	Android::set_ndk_dir ""

	# find android ndk
	for ANDROID_ROOT_DIR in ${ANDROID_ROOT_DIR_LIST[@]}; do
		if [ ! -d $ANDROID_ROOT_DIR ]; then
			continue;
		fi

		for f in $(ls $ANDROID_ROOT_DIR | sort -r); do
			local TARGET=${ANDROID_ROOT_DIR}/$f
			if [ -f $TARGET ]; then
				continue
			fi
			if [[ $f == *"ndk"* ]]; then
				Android::set_ndk_dir $TARGET
			fi
		done
	done
}

function Android::set_sdk_dir {
	if [[ "$1" == "" ]]; then
		unset ANDROID_SDK_ROOT
		unset ANDROID_HOME
	else
		export PATH=$1/platform-tools:$PATH
		export PATH=$1/tools:$PATH
		export ANDROID_SDK_ROOT=$1
		export ANDROID_HOME=$1
	fi
}

function Android::set_ndk_dir {
	if [[ "$1" == "" ]]; then
		unset ANDROID_NDK_VERSION
		unset ANDROID_NDK_ROOT
		unset NDK_ROOT
	else
		# example : android-ndk-r8e
		export ANDROID_NDK_VERSION=`expr "$1" : '.*ndk-\(r[0-9]*[a-z]\)'`
		export ANDROID_NDK_ROOT=$1
		export NDK_ROOT=$1
		export PATH=${ANDROID_NDK_ROOT}:$PATH
	fi
}

function Android::display {
	echo "## Android"

	if [[ $ANDROID_SDK_ROOT == "" ]]; then
		echo "Android SDK is not exist"
	else
		echo "Android SDK\t: ${ANDROID_SDK_ROOT}"
	fi

	if [[ $ANDROID_NDK_ROOT == "" ]]; then
		echo "NDK is not exist"
	else
		echo "NDK(${ANDROID_NDK_VERSION})\t: ${ANDROID_NDK_ROOT}"
	fi

	if [[ $NDK_CCACHE == "" ]]; then
		echo "ccache is not exist"
	else
		echo "ccache\t\t: Enabled"
	fi
	echo ""
}

function Android::ccache {
	# ccache
	export NDK_CCACHE=`which ccache`
}


function Android::reset_adb {
	# http://stackoverflow.com/questions/9210152/set-up-device-for-development-no-permissions
	# Fix this problem
	# List of devices attached
	# ????????????    no permissions
	# Configure udev or use root permission
	# I use root permission becuase zshrc configuration file is used in many computer.
	sudo adb kill-server
	sudo adb start-server
	sudo adb devices
}

function Android::setup {
	#http://stackoverflow.com/questions/22701405/aapt-ioexception-error-2-no-such-file-or-directory-why-cant-i-build-my-grad
	# for x86_64 + android sdk
	sudo apt-get install lib32stdc++6 lib32z1
}

function Nodejs::init {
	# nvm
	mkdir -p $HOME/.nvm
	export NVM_DIR=$HOME/.nvm

	if [[ $OS_TYPE == "osx" ]]; then
		# OSX : brew + nvm
		source $(brew --prefix nvm)/nvm.sh
	else
		. ~/.nvm/nvm.sh
	fi
}


function Ruby::init {
	export PATH="$HOME/.rbenv/bin:$PATH"
	export PATH="$HOME/.rbenv/plugins/ruby-build/bin:$PATH"
	eval "$(rbenv init -)" || 1
}

function Python::init {
	export PYENV_ROOT="$HOME/.pyenv"
	export PATH="$PYENV_ROOT/bin:$PATH"
	eval "$(pyenv init -)" || 1
	eval "$(pyenv virtualenv-init -)" || 1
}

function Emacs::init {
	export PATH="$HOME/.cask/bin:$PATH"
}

function MacOSX::init {
	if [[ $OS_TYPE != "osx" ]]; then
		return
	fi

	echo "## MacOSX "

	# mysql
	# http://stackoverflow.com/questions/10557507/rails-mysql-on-osx-library-not-loaded-libmysqlclient-18-dylib
	MYSQL=/usr/local/mysql/bin
	if [ -d $MYSQL ]; then
		echo "mysql detected"
		export PATH=$PATH:$MYSQL
		export DYLD_LIBRARY_PATH=/usr/local/mysql/lib:$DYLD_LIBRARY_PATH
	fi

	# emacs
	local emacs_path="/usr/local/opt/emacs/bin"
	if [ -d $emacs_path ]; then
		echo "emacs detected"
		export PATH=/usr/local/opt/emacs/bin:$PATH
	fi

	# hangul locale
	export LC_ALL="ko_KR.UTF-8"
	export LANG="ko_KR.UTF-8"

	echo ""
}

function Local::init {
	local zshrc_local="$HOME/.zshrc.local"
	if [ ! -f $zshrc_local ]; then
		return
	fi

	echo "## Local"
	echo "Include Local zshrc"
	source $zshrc_local
	echo ""
}

zmodload zsh/datetime

function Dotfiles::init {
	Dotfiles::update
}

function _current_epoch() {
	echo $(( $EPOCHSECONDS / 60 / 60 / 24 ))
}

function Dotfiles::update_repo {
	curr_path=$(pwd)
	cd ~/.dotfiles
	git pull origin master
	cd $curr_path

	Dotfiles::update_timestamp
}
function Dotfiles::update_timestamp {
	echo "LAST_EPOCH=$(_current_epoch)" >! ~/.dotfiles-update
}
function Dotfiles::update {
	# https://github.com/robbyrussell/oh-my-zsh/blob/master/tools/check_for_upgrade.sh

	if [ -f ~/.dotfiles-update ]; then
		. ~/.dotfiles-update

		epoch_target=1

		if [[ -z "$LAST_EPOCH" ]]; then
			Dotfiles::update_timestamp && return 0;
		fi

		epoch_diff=$(($(_current_epoch) - $LAST_EPOCH))
		if [ $epoch_diff -gt $epoch_target ]; then
			if [ "$DISABLE_UPDATE_PROMPT" = "true" ]; then
				_upgrade_zsh
			else
				echo "[Dotfiles] Would you like to check for updates? [Y/n]: \c"
				read line
				if [ "$line" = Y ] || [ "$line" = y ] || [ -z "$line" ]; then
					Dotfiles::update_repo
				else
					Dotfiles::update_timestamp
				fi
			fi
		fi
	else
		# create the timestamp file
		Dotfiles::update_timestamp
	fi
}


Zsh::init
Dotfiles::init
Shell::init
System::init
System::display

# OSX 초기화를 먼저 하지 않으면 brew로 문제 생길 가능성이 있다
MacOSX::init

Emacs::init
Android::init
Android::display

# 언어 관련 설정은 나중
Ruby::init
Python::init
Nodejs::init

Local::init

echo "Hello, $USER."

# automatic added
# added by travis gem
[ -f /home/haruna/.travis/travis.sh ] && source /home/haruna/.travis/travis.sh

### Added by the Heroku Toolbelt
export PATH="/usr/local/heroku/bin:$PATH"
