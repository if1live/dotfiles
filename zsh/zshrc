function Zsh::init {
	# Path to your oh-my-zsh configuration.
	ZSH=~/.oh-my-zsh

	# Set name of the theme to load.
	# Look in ~/.oh-my-zsh/themes/
	# Optionally, if you set this to "random", it'll load a random theme each
	# time that oh-my-zsh is loaded.
	#ZSH_THEME="gianu"
	#ZSH_THEME="cypher"
	#ZSH_THEME="rkj"
	ZSH_THEME="candy"

	# Set this to use case-sensitive completion
	# CASE_SENSITIVE="true"

	# Uncomment this to disable bi-weekly auto-update checks
	# DISABLE_AUTO_UPDATE="true"

	# Uncomment to change how often to auto-update? (in days)
	export UPDATE_ZSH_DAYS=13

	# Uncomment following line if you want to disable colors in ls
	# DISABLE_LS_COLORS="true"

	# Uncomment following line if you want to disable autosetting terminal title.
	# DISABLE_AUTO_TITLE="true"

	# Uncomment following line if you want to disable command autocorrection
	# DISABLE_CORRECTION="true"

	# Uncomment following line if you want red dots to be displayed while waiting for completion
	# COMPLETION_WAITING_DOTS="true"

	# Uncomment following line if you want to disable marking untracked files under
	# VCS as dirty. This makes repository status check for large repositories much,
	# much faster.
	# DISABLE_UNTRACKED_FILES_DIRTY="true"

	# Uncomment following line if you want to the command execution time stamp shown
	# in the history command output.
	# The optional three formats: "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"
	HIST_STAMPS="yyyy/mm/dd"

	# Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)
	# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/
	# Example format: plugins=(rails git textmate ruby lighthouse)
	plugins=(
		tmux
		git github git-flow
		node npm grunt coffee
		pip python fabric
		ruby rails
		#thefuck
	)

	source $ZSH/oh-my-zsh.sh
}


function System::release_name {
	DEBIAN_RELEASE_FILE="/etc/lsb-release"
	REDHAT_RELEASE_FILE="/etc/redhat-release"

	# OS_TYPE : linux / osx / unknown ...
	# 맥의 경우는 환경설정이 달라질때가 많다.
	# 매번 확인하기 귀찮아서 환경변수로 설정

	if [ -f $DEBIAN_RELEASE_FILE ]; then
		# ubuntu, debian, etc
		local DIST_NAME=$(sed -n 's/^DISTRIB_ID=//p' $DEBIAN_RELEASE_FILE)
		local DIST_VERSION=$(sed -n 's/^DISTRIB_RELEASE=//p' $DEBIAN_RELEASE_FILE)
		CHROMEOS_RELEASE_DESCRIPTION=$(sed -n 's/^CHROMEOS_RELEASE_DESCRIPTION=//p' $DEBIAN_RELEASE_FILE)

		if [[ $DIST_NAME == "" ]]; then
			DIST_FULLNAME="$CHROMEOS_RELEASE_DESCRIPTION"
			export OS_TYPE="chromeos"
		else
			DIST_FULLNAME="$DIST_NAME $DIST_VERSION"
			export OS_TYPE="linux"
		fi
	elif [ -f $REDHAT_RELEASE_FILE ]; then
		# centos
		DIST_FULLNAME=`cat $REDHAT_RELEASE_FILE`
		export OS_TYPE="linux"
	elif [ -d "/Applications" ]; then
		# 맥인지 확인하는 무식한 방법
		# 설마 리눅스에서 /Applications 디렉토리를 만들겠어?
		local DIST_NAME=$(sw_vers -productName)
		local DIST_VERSION=$(sw_vers -productVersion)
		local DIST_BUILD=$(sw_vers -buildVersion)
		DIST_FULLNAME="$DIST_NAME $DIST_VERSION $DIST_BUILD"
		export OS_TYPE="osx"
	else
		DIST_FULLNAME="Unknown Distribution"
		export OS_TYPE="unknown"
	fi
}

function System::environment {
	if [[ $USER == "haruna" ]]; then
		ENV_NAME="Work"
	elif [[ $USER == "amane" ]]; then
		ENV_NAME="Work"
	elif [[ $USER == "pi" ]]; then
		ENV_NAME="Raspberry Pi"
	elif [[ $USER == "chronos" ]]; then
		ENV_NAME="ChromeOS"
	else
		ENV_NAME="Home"
	fi
}

function System::env_hook_rpi {
	alias ssh-pi="ssh pi@192.168.0.16"
}

function System::init {
	System::release_name
	System::environment

	if [[ $ENV_NAME == "pi" ]]; then
		System_env_hook_rpi
	fi
}

function System::display {
	echo ""
	echo "## Environment"
	echo "OS Type\t\t: ${OS_TYPE}"
	echo "User\t\t: ${USER}"
	echo "Computer\t: ${DIST_FULLNAME}"
	echo "Environment\t: ${ENV_NAME}"
	echo ""
}

function Shell::init {
	# User configuration
	export PATH="/usr/lib/lightdm/lightdm:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games"
	export MANPATH="/usr/local/man:$MANPATH"
	export PATH="$HOME/bin:$PATH"

	# # Preferred editor for local and remote sessions
	if [[ -n $SSH_CONNECTION ]]; then
		export EDITOR='vim'
	else
		export EDITOR='vim'
	fi
	export VISUAL=$EDITOR

	# Compilation flags
	export ARCHFLAGS="-arch x86_64"

	# python encoding
	export PYTHONIOENCODING="utf-8"

	# ssh
	export SSH_KEY_PATH="~/.ssh/id_rsa"

	export LC_ALL=ko_KR.UTF-8
	export LANG=ko_KR.UTF-8

	if [ -f "~/.autoenv/" ]; then
	    source ~/.autoenv/activate.sh
	fi

	# the fuck
	# https://github.com/nvbn/thefuck
	# eval "$(thefuck --alias)"

	# less + syntax highlight
	# http://superuser.com/questions/117841/get-colors-in-less-command
	export LESS='-R'
	export LESSOPEN='|~/.lessfilter %s'

	Shell::alias
}

function Shell::alias {
	alias cd...='cd ../..'
	alias cd....='cd ../../..'
	alias cd.....='cd ../../../..'
	alias cd......='cd ../../../../..'

	# cls is dos command. but it is short than clear.
	alias cls='clear'

	alias emasc='emacs'
	alias e='emacs'

	# use color
	alias less='less -R'

	# apt-get install ack-grep
	# linux : ack-grep
	# osx : ack
	unalias ack 2> /dev/null
	ack_exist=$(which ack > /dev/null 2> /dev/null; echo $?)
	ack_grep_exist=$(which ack-grep > /dev/null 2> /dev/null; echo $?)
	if [[ $ack_grep_exist == "0" ]] && [[ $ack_exist != "0" ]]; then
		echo "[Shell]\t ack-grep found, ack not found => enable ack alias"
		alias ack='ack-grep'
	fi

	alias ipconfig='ifconfig'

	# mcs/gmcs 둘다 돌아가도록
	mcs_exist=$(which mcs > /dev/null 2> /dev/null; echo $?)
	gmcs_exist=$(which gmcs > /dev/null 2> /dev/null; echo $?)
	if [[ $mcs_exist == "0" ]] && [[ $gmcs_exist != "0" ]]; then
		alias gmcs="mcs"
	fi
	if [[ $gmcs_exist == "0" ]] && [[ $mcs_exist != "0" ]]; then
		alias mcs="gmcs"
	fi

	# not recommend. python embedded web server is slow
	# user npm install -g http-server
	alias serve='python -m SimpleHTTPServer'

	alias py2='python2'
	alias py3='python3'
}

function Local::init {
	local zshrc_local="$HOME/.zshrc.local"
	if [ ! -f $zshrc_local ]; then
		return
	fi

	echo "## Local"
	echo "Include Local zshrc"
	source $zshrc_local
	echo ""
}

zmodload zsh/datetime

function Dotfiles::init {
	Dotfiles::update
}

function _current_epoch() {
	echo $(( $EPOCHSECONDS / 60 / 60 / 24 ))
}

function Dotfiles::update_repo {
	curr_path=$(pwd)
	cd ~/.dotfiles
	git pull origin master
	cd $curr_path

	Dotfiles::update_timestamp
}
function Dotfiles::update_timestamp {
	echo "LAST_EPOCH=$(_current_epoch)" >! ~/.dotfiles-update
}
function Dotfiles::update {
	# https://github.com/robbyrussell/oh-my-zsh/blob/master/tools/check_for_upgrade.sh

	if [ -f ~/.dotfiles-update ]; then
		. ~/.dotfiles-update

		epoch_target=1

		if [[ -z "$LAST_EPOCH" ]]; then
			Dotfiles::update_timestamp && return 0;
		fi

		epoch_diff=$(($(_current_epoch) - $LAST_EPOCH))
		if [ $epoch_diff -gt $epoch_target ]; then
			if [ "$DISABLE_UPDATE_PROMPT" = "true" ]; then
				_upgrade_zsh
			else
				echo "[Dotfiles] Would you like to check for updates? [Y/n]: \c"
				read line
				if [ "$line" = Y ] || [ "$line" = y ] || [ -z "$line" ]; then
					Dotfiles::update_repo
				else
					Dotfiles::update_timestamp
				fi
			fi
		fi
	else
		# create the timestamp file
		Dotfiles::update_timestamp
	fi
}

cd ~
Zsh::init
Dotfiles::init
Shell::init
System::init
System::display

Local::init

echo "Hello, $USER."


# add libs
local DOTFILES_LIBS_PATH=$HOME/.dotfiles/zsh/libs/
for lib in $DOTFILES_LIBS_PATH/*.zsh; do
    source $lib
done

# initialize minimum lib
# step 1. system, os
# OSX 초기화를 먼저 하지 않으면 brew로 문제 생길 가능성이 있다
dotfiles::osx::init
dotfiles::chromeos::init

# step 2. application
dotfiles::emacs::init
dotfiles::docker::init
dotfiles::travis::init
dotfiles::heroku::init


# 언어 관련 라이브러리 초기화는 필수 패키지에서 제외
# * 모든 경우에 쓰이는게 아니다
# * 옛날에는 nvm, gvm같은거 썻는데 귀찮아서 apt-get 통해 설치하기 시작
# * 쉘 새로 뜰때마다 실행하기에는 초기화가 느리다
# lib는 남겨뒀으니 필요할떄 직접 호출하자


